---
title: Write Fractal Message to Blockchain
---

## Flow 
- Select UTXOs to Spend
- Calculate Fee
- Send Expected Amount to Seller address (If a payment)
- Send (Remaining - Fee) to your address (for the change)
- Create Raw Transaction
- Sign Transaction
- Send Signed Transaction

## Go example (Writing a Fractal Mint to Blockchain)

```go
 package main

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"

	fecfg "dogecoin.org/fractal-engine/pkg/config"
	"dogecoin.org/fractal-engine/pkg/doge"
	"dogecoin.org/fractal-engine/pkg/protocol"
	"github.com/btcsuite/btcd/chaincfg"
)

func main() {
	// NOTE: These are example values, you will need to replace them with your own values
	mintHashFromApiCall := "MINT_HASH"
	utxoTxId := "TXID"
	utxoVout := 0
	utxoAmount := 1000
	feeAmount := 1
	privHex := "YOUR_PRIVATE_KEY"
	address := "YOUR_ADDRESS_FOR_CHANGE"

	envelope := protocol.NewMintTransactionEnvelope(mintHashFromApiCall, protocol.ACTION_MINT)
	encodedTransactionBody := envelope.Serialize()

	inputs := []interface{}{
		map[string]interface{}{
			"txid": utxoTxId,
			"vout": utxoVout,
		},
	}

	outputs := map[string]interface{}{
		"data":  hex.EncodeToString(encodedTransactionBody),
		address: utxoAmount - feeAmount,
	}

	dogeClient := doge.NewRpcClient(&fecfg.Config{
		DogeScheme:   "http",
		DogeHost:     "your_dogecoin_node_host",
		DogePort:     "22555",
		DogeUser:     "test",
		DogePassword: "test",
	})

	rawTx, err := dogeClient.Request("createrawtransaction", []interface{}{inputs, outputs})
	if err != nil {
		log.Fatal(err)
	}

	var rawTxResponse string
	if err := json.Unmarshal(*rawTx, &rawTxResponse); err != nil {
		log.Fatal(err)
	}

	encodedTx, err := doge.SignRawTransaction(rawTxResponse, privHex, []doge.PrevOutput{
		{
			Address: address,
			Amount:  int64(utxoAmount),
		},
	}, &chaincfg.MainNetParams)

	if err != nil {
		log.Fatal(err)
	}

	res, err := dogeClient.Request("sendrawtransaction", []interface{}{encodedTx})
	if err != nil {
		log.Println("error sending raw transaction", err)
		return
	}

	var txid string

	if err := json.Unmarshal(*res, &txid); err != nil {
		log.Println("error parsing send raw transaction response", err)
		return
	}

	fmt.Println("Transaction sent: " + txid)
}
```
 
## Typescript Example (Writing a Fractal Mint to Blockchain)
```typescript
import km2, { Crypto, UnsignedTransaction, Net, Language } from "@houseofdoge/km2";

const FE_URL = "http://HOST_OF_YOUR_FRACTAL_ENGINE:PORT_OF_YOUR_FRACTAL_ENGINE";
const KOINU = 100_000_000;

const dogeToKoinu = (s: string): number => {
    const m = s.trim().match(/^([+-])?(\d+)(?:\.(\d{0,8}))?$/);
    if (!m) throw new Error(`invalid amount: ${s}`);
    const sign = m[1] === "-" ? -1 : 1;
    const w = m[2].replace(/^0+/, "") || "0";
    const f = (m[3] || "").padEnd(8, "0");

    // Max safe: whole <= 90,071,992 (because (whole*1e8 + frac) must fit 2^53-1)
    if (w.length > 8 || (w.length === 8 && Number(w) > 90071992)) {
        throw new Error("amount too large for a JS number; use the string version");
    }

    return sign * (Number(w) * KOINU + Number(f));
};

const koinuToDoge = (k: number): string =>
    `${k / KOINU}.${(k % KOINU).toString().padStart(8, "0")}`;


const sendSignedTransaction = async (
    encodedTrxnHex: string,
): Promise<string> => {

    const res = await fetch(FE_URL + "/doge/send", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            Accept: "application/json",
        },
        body: JSON.stringify({
            encoded_transaction_hex: encodedTrxnHex,
        }),
    });

    const resJson = await res.json();

    return resJson.raw_transaction_hex;
};

// This is an example API response from the /mints endpoint for Fractal Engine
const mintResponse = {
    encoded_transaction_body: "0x0000000000000000000000000000000000000000000000000000000000000000",
}

// Example UTXO, you will need to retrieve this from your wallet
const utxos = [
    {
        value: "1.0",
        vout: 0,
        tx: "0x0000000000000000000000000000000000000000000000000000000000000000",
        script: "0x0000000000000000000000000000000000000000000000000000000000000000",
    }
];
// NOTE: This is a pretty crude way of figuring out UTXOs and Fees.
const totalValue = dogeToKoinu(utxos[0].value);
const totalFee = dogeToKoinu("0.002");

// This will generate a new wallet (purely for example purposes), you will need to use an existing wallet that contains DOGE for fees or for payments.
using seed = new km2.SeedPhrase({
    wordCount: 24,
    language: Language.English,
});

using wallet = new km2.Wallet(seed, {
    cryptocurrency: Crypto.Dogecoin,
    network: Net.Mainnet
});

using kp = wallet.deriveKeypair({ account: 1, change: 0, index: 0 });

const unsignedTrxn = new UnsignedTransaction(Crypto.Dogecoin, Net.Mainnet);

unsignedTrxn.addInput({
    outputIndex: utxos[0].vout,
    prevTxId: utxos[0].tx,
    scriptPubKeyHex: utxos[0].script,
    value: totalValue,
    sequence: 0xffffffff,
});

unsignedTrxn.addOutput({
    kind: "payment",
    address: "address_of_the_receiver",
    value: totalValue - totalFee,
});

unsignedTrxn.addOutput({
    kind: "opReturn",
    data: mintResponse.encoded_transaction_body,
    value: 0,
});

const signedTrxn = unsignedTrxn.sign({
    keypairs: [kp],
});

const trxnId = await sendSignedTransaction(signedTrxn.rawHex);

console.log(trxnId);
```
